<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Vetores</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="vetores">Vetores</h1>
<p>Vetores são estruturas de dados muito legais em qualquer linguagem. Basicamente permite armazenar uma quantidade prédeterminada, ou indeterminada, de elementos e é possivel organiza-los dentro do vetor da forma que quiser.</p>
<p>Cada casa de um vetor geralmente é referenciada por um inteiro, indentificando a posição que determinado valor foi salvo. Dependendo da linguagem é possivel também possuir um vetor não continuo, ou seja, pode possuir a casa N mas não necessáriamente possue todas as casas de 0 a N, ou vetores no qual a chave da casa pode ser uma string ou até outro referenciador, sendo mais comum nesses casos serem chamados de <em>dictionary</em>.</p>
<h2 id="c---stdvector">C++ - <a href="https://cplusplus.com/reference/vector/vector/">std::vector</a></h2>
<h3 id="sequência">Sequência</h3>
<p>Os elementos em contêineres de sequência são ordenados em uma sequência linear estrita. Elementos individuais são acessados por sua posição nesta sequência.</p>
<h3 id="vetor-dinâmico">Vetor dinâmico</h3>
<p>Permite acesso direto a qualquer elemento na sequência, mesmo por meio de aritmética de ponteiro, e fornece adição/remoção relativamente rápida de elementos no final da sequência.</p>
<h3 id="dinamicamente-alocado">Dinamicamente Alocado</h3>
<p>O contêiner usa um objeto alocador para lidar dinamicamente com suas necessidades de armazenamento.</p>
<p>As principais funções utilizadas no vetor são as citadas abaixo:</p>
<h3 id="iteração">Iteração:</h3>
<ul>
<li>begin(): retorna um iterador a partir do inicio do vetor;</li>
<li>end(): retorna um iterador a partir do fim do vetor (não pega a ultima casa);</li>
<li>rbegin(): retorna um iterador <em>reverso</em> a partir do fim do vetor;</li>
<li>rend(): retorna um iterador <em>reverso</em> a partir do inicido do vetor (não pega a primeira casa);</li>
</ul>
<h3 id="getters">Getters:</h3>
<ul>
<li>operator[]: retorna o elemento da casa indicada dentro do operator. Caso seja uma posição maior que a quantidade de itens então causa um <em>comportamento não definido</em>;</li>
<li>front(): retorna o primeiro elemento;</li>
<li>back(): retorna o ultimo elemento;</li>
</ul>
<h3 id="capacidade">Capacidade:</h3>
<ul>
<li>size(): retorna o tamanho do vetor;</li>
<li>empty(): retorna true se o vetor estiver vazio;</li>
<li>capacity(): retorna o tamanho alocado atualmente para esse vetor;</li>
<li>reserve(): reseva o tamanho informado para esse vetor;</li>
</ul>
<h3 id="modificadores">Modificadores:</h3>
<ul>
<li>push_back(): adiciona um elemento ao final do vetor;</li>
<li>pop_back(): remove um elemento ao final do vetor;</li>
<li>insert(): existem algumas versões para o insert, sendo elas:</li>
<li>insert(iterator pos, val): a partir da posição, insere o item val;</li>
<li>insert(iterator pos, start, end): a partir da posição, insere o array que começa em start e termina em end;</li>
<li>erase(): apaga um elemento na posição passada, note que para remover o elemento da posição 4 deve-se chamar a função begin() e somar a 4;</li>
</ul>
<pre><code class="language-C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span>

vector&lt;<span class="hljs-type">int</span>&gt; *x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">25</span>); <span class="hljs-comment">//x = (25, 25, 25)</span>
<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span> <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// y = (0, 0, 0, 0, 0)</span>
*x = y; <span class="hljs-comment">// x = (0, 0, 0, 0, 0)</span>

<span class="hljs-type">int</span> s[<span class="hljs-number">3</span>] = {<span class="hljs-number">100</span>, <span class="hljs-number">231</span>, <span class="hljs-number">213</span>};
y.<span class="hljs-built_in">assign</span>(s, s+<span class="hljs-number">3</span>); <span class="hljs-comment">// x = (0, 0, 0, 0, 0) e y = (100, 231, 213)</span>

y.<span class="hljs-built_in">insert</span>(y.<span class="hljs-built_in">begin</span>(), s, s+<span class="hljs-number">3</span>); <span class="hljs-comment">// y = (100, 231, 213, 100, 231, 213)</span>
y.<span class="hljs-built_in">erase</span>(y.<span class="hljs-built_in">begin</span>(), y.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>); <span class="hljs-comment">// y = (213, 100, 231, 213)</span>

y.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// == y[1] e assim por diante</span>

vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;
<span class="hljs-keyword">for</span>(it = y.<span class="hljs-built_in">begin</span>(); it != y.<span class="hljs-built_in">end</span>(); it++)
cout &lt;&lt; *it &lt;&lt; endl;  
</code></pre>
<h2 id="python---list">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html">list</a></h2>
<p>Em python não existem vetores, ao invéz disso todos as estruturas de array que são trabalhadas na linguagem se utiliza a estrutura de <a href="./Lista.html#python-list">listas</a>.</p>
<h1 id="lista">Lista</h1>
<p>Listas são contêineres de sequência que permitem operações de inserção e apagamento de tempo constante em qualquer lugar dentro da sequência e iteração em ambas as direções.</p>
<p>Os contêineres de lista são implementados como listas duplamente vinculadas; As listas duplamente vinculadas podem armazenar cada um dos elementos que contêm em locais de armazenamento diferentes e não relacionados. A ordenação é mantida internamente pela associação a cada elemento de um link para o elemento que o precede e um link para o elemento que o segue.</p>
<h2 id="c---stdlist">C++ - <a href="https://cplusplus.com/reference/list/list/">std::list</a></h2>
<h3 id="sequência-1">Sequência</h3>
<p>Os elementos em contêineres de sequência são ordenados em uma sequência linear estrita. Elementos individuais são acessados por sua posição nesta sequência.</p>
<h3 id="lista-duplamente-ligada">Lista duplamente ligada</h3>
<p>Cada elemento guarda informações sobre como localizar o próximo e os anteriores, permitindo operações de inserção e apagamento em tempo constante antes ou depois de um elemento específico (mesmo de faixas inteiras), mas sem acesso aleatório direto.</p>
<h3 id="dinamicamente-alocado-1">Dinamicamente Alocado</h3>
<p>O contêiner usa um objeto alocador para lidar dinamicamente com suas necessidades de armazenamento</p>
<p>As principais funções utilizadas nas listas são as citadas abaixo:</p>
<h3 id="iteração-1">Iteração:</h3>
<ul>
<li>begin(): retorna um iterador a partir do inicio da lista;</li>
<li>end(): retorna um iterador a partir do fim da lista (não pega a ultima casa);</li>
<li>rbegin(): retorna um iterador <em>reverso</em> a partir do fim da lista;</li>
<li>rend(): retorna um iterador <em>reverso</em> a partir do inicido da lista (não pega a primeira casa);</li>
</ul>
<h3 id="getters-1">Getters:</h3>
<ul>
<li>front(): retorna o primeiro elemento;</li>
<li>back(): retorna o ultimo elemento;</li>
</ul>
<h3 id="capacidade-1">Capacidade:</h3>
<ul>
<li>size(): retorna o tamanho da lista;</li>
<li>empty(): retorna true se a lista estiver vazio;</li>
</ul>
<h3 id="modificadores-1">Modificadores:</h3>
<ul>
<li>push_back(): adiciona um elemento ao final da lista;</li>
<li>pop_back(): remove um elemento do final da lista;</li>
<li>push_front(): adiciona um elemento ao inicio da lista;</li>
<li>pop_front(): remove um elemento do inicio da lista;</li>
<li>insert(): existem algumas versões para o insert, sendo elas:</li>
<li>insert(iterator pos, val): a partir da posição, insere o item val;</li>
<li>insert(iterator pos, start, end): a partir da posição, insere o array que começa em start e termina em end;</li>
<li>erase(): apaga um elemento na posição passada, note que para remover o elemento da posição 4 deve-se chamar a função begin() e somar a 4;</li>
</ul>
<h3 id="operadores">Operadores:</h3>
<ul>
<li>sort(): Ordena os elementos da lista, é possivel passar uma função para fazer a comparação;</li>
<li>merge(): Junta duas listas ordenadas, a lista final vai estar ordenada;</li>
<li>remove(): Remove todos os elementos que possuem o mesmo valor passado no parametro;</li>
<li>remove_if(): Remove todos os elementos que passam na condição. O parametro é uma função que é aplicada em todos os elementos, e deve retornar true ou false, sendo true para remover e false para manter na lista;</li>
</ul>
<h2 id="python---list-1">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html">list</a></h2>
<p>As principais funções utilizadas nas listas são as citadas abaixo:</p>
<h3 id="modificadores-2">Modificadores:</h3>
<ul>
<li>append(x): adiciona o elemento x ao final da lista;</li>
<li>extend(<em>iterable</em>): adiciona todos os elementos do <em>iterable</em>* a lista;</li>
<li>insert(i,x): insere o item x a posição i da lista;</li>
<li>remove(x): remove o primeiro item que seja igual a x;</li>
<li>clear(): remove todos os elementos da lista;</li>
</ul>
<h3 id="operadores-1">Operadores:</h3>
<ul>
<li>sort(): ordena a lista;</li>
<li>key= fn(x) : o parametro key da função sort deve receber uma função que tem 1 parametro e retorna uma chave de comparação. Isso é bom quando se tem uma lista de objeto e para fazer o sort é necessário do item id do objeto, ou outro valor;</li>
<li>reverse= bool : define se deve ordenar a lista de forma crescente ou decrescente;</li>
<li>reverse(): reverte a lista;</li>
<li>copy(): faz uma copia completa da lista;</li>
</ul>
<h3 id="getters-2">Getters:</h3>
<ul>
<li>list.count(x): retorna a contagem de quantos elementos iguais ao x existem na lista;</li>
</ul>
<p>* <em>iterable</em> em python é qualquer extrutura de dados que pode ser acessada de forma iterativa, e implementa a interface <em>iterable</em></p>
<p>Note que em python, boa parte das função auxiliares não retornam uma lista, e sim um <em>iterable</em>. Caso queira converter um <em>iterable</em> em uma lista para poder utilizar as funções de lista use o seguinte código:</p>
<pre><code class="language-python">l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,l) <span class="hljs-comment"># a função map não retorna uma lista, e sim um objeto que extende iterable</span>
l = [* m ] <span class="hljs-comment"># dessa forma o python abre nosso iterable dentro de uma lista</span>
</code></pre>
<p>Existem algumas formas de criar um array de maneira fácil em pyton:</p>
<pre><code class="language-python">fruits = [<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;longberry&#x27;</span>,<span class="hljs-string">&#x27;passion fruit&#x27;</span>]
zeros = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]
squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]
nums = [*<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)] <span class="hljs-comment">#Note que range também é um iterable logo é possivel abri-lo dentro de uma lista</span>

ofMap = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x/<span class="hljs-number">2</span>,<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))   <span class="hljs-comment">#Note que list(...) é uma outra forma de escrever [*...]</span>

val = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
a,b,c = val <span class="hljs-comment"># note que é possivel desconstruir uma lista em que cada valor vai para uma variavel, mas é necessário que a lista tenha a mesma quantidade de valores que as variaves que recebem o valor.</span>

</code></pre>
<p>Outra forma de remover um elemento de uma lista <strong>sem retorna-lo</strong> é utilizando a chamada <em>del</em> do python. Segue um exemplo:</p>
<pre><code class="language-python">
a = [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">66.25</span>, <span class="hljs-number">333</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1234.5</span>]
<span class="hljs-keyword">del</span> a[<span class="hljs-number">0</span>] <span class="hljs-comment"># remove o elemento na posição 0</span>
<span class="hljs-keyword">del</span> a[:<span class="hljs-number">2</span>] <span class="hljs-comment"># remove todos os elementos até a posição 2</span>
<span class="hljs-keyword">del</span> a[<span class="hljs-number">2</span>:] <span class="hljs-comment"># remove todos os elementos a partir da posição 2</span>
<span class="hljs-keyword">del</span> a[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] <span class="hljs-comment"># remove todos os elementos a partir da posição 2 até a posição 4</span>
<span class="hljs-keyword">del</span> a[:] <span class="hljs-comment"># remove todos os elementos do vetor</span>
</code></pre>
<h1 id="pilha">Pilha</h1>
<p>Pilha, ou também chamada de stack, é uma estrutura de dados que se baseaia no príncipio LIFO (<em>LAST IN FIRST OUT</em>).</p>
<p>Pilhas são fundamentalmente compostas por duas operações: push (empilhar) que adiciona um elemento no topo da pilha e pop (desempilhar) que remove o último elemento adicionado.</p>
<h2 id="c---stdstack">C++ - <a href="https://cplusplus.com/reference/stack/stack/">std::stack</a></h2>
<p>As principais funções utilizadas na stack são as citadas abaixo:</p>
<ul>
<li>empty(): testa se a stack está vazia;</li>
<li>size(): retorna o tamanho da stack;</li>
<li>push(T): insere no topo da pilha o item T;</li>
<li>pop(): remove o elemento do topo da pilha, destaque que ele <strong>não retorna</strong> esse elemento, ele apenas remove;</li>
<li>top(): retorna o elemento do topo da pilha, sem remove-lo;</li>
</ul>
<p>Abaixo um exemplo de utilização da stack:</p>
<pre><code class="language-C++"><span class="hljs-comment">// stack::push/pop</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span>          <span class="hljs-comment">// std::stack</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>
</span>{
  std::stack&lt;<span class="hljs-type">int</span>&gt; mystack;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; ++i) mystack.<span class="hljs-built_in">push</span>(i);
  std::cout &lt;&lt; <span class="hljs-string">&quot;Popping out elements...&quot;</span>;
  <span class="hljs-keyword">while</span> (!mystack.<span class="hljs-built_in">empty</span>())
  {
     std::cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; mystack.<span class="hljs-built_in">top</span>();
     mystack.<span class="hljs-built_in">pop</span>();
  }
  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="python---deque">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-queues">deque</a></h2>
<p>Em python não existe pilha, mas ao mesmo tempo existe a estrutura <em>deque</em> que é possivel utilizar as mesmas operações de uma stack, então <a href="./DoubleEndedQueue.html">acesse aqui</a> para saber mais.</p>
<h1 id="double-ended-queue">Double Ended Queue</h1>
<p>É um array no qual é possivel adicionar valores no inico e no final e também remover valores de ambos os lados.
Não necessáriamente o acesso a uma posição especifica do array vai garantir um acesso constante O(1), mas a inserção e remoção no inicio e final é sempre constante O(1)</p>
<h2 id="python---deque-1">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-queues">deque</a></h2>
<p>Em python existe a estrutura de dados <em>deque</em> (Double Ended Queue) que é desenvolvida para ter <em>rápidas</em> inserções e remoções para o início e o fim da lista.</p>
<p>Um <em>deque</em> pode ser usado da seguinte forma:</p>
<pre><code class="language-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
dq = deque(l) <span class="hljs-comment"># cria um deque a partir de uma lista, O(n)</span>
dq.append(<span class="hljs-number">7</span>) <span class="hljs-comment"># adiciona ao final do deque o item 7, O(1)</span>
dq.appendleft(<span class="hljs-number">7</span>) <span class="hljs-comment"># adiciona ao inicio do deque o item 7, O(1)</span>
dq.popleft() <span class="hljs-comment"># retorna e remove o primeiro elemento do deque, O(1)</span>
dq.pop() <span class="hljs-comment"># retorna e remove o ultimo elemento do deque, O(1)</span>
dq.rotate(<span class="hljs-number">5</span>) <span class="hljs-comment"># ´rotaciona´ uma deque. rotate(5) fará 5 rotações no sentido normal (esquerda para direita). rotate(-5) faz no oposto (direita para esquerda)</span>
</code></pre>
<h2 id="c---deque">C++ - <a href="https://cplusplus.com/reference/deque/deque/">deque</a></h2>
<p>Specific libraries may implement deques in different ways, generally as some form of dynamic array. But in any case, they allow for the individual elements to be accessed directly through random access iterators, with storage handled automatically by expanding and contracting the container as needed.</p>
<p>Therefore, they provide a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in a deque by offsetting a pointer to another element causes undefined behavior.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>
</span>{
    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">second</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">100</span>)</span></span>;                       <span class="hljs-comment">// four ints with value 100</span>
    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">third</span><span class="hljs-params">(second.begin(),second.end())</span></span>;  <span class="hljs-comment">// iterating through second</span>
    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fourth</span><span class="hljs-params">(third)</span></span>;                       <span class="hljs-comment">// a copy of third</span>

    <span class="hljs-comment">// the iterator constructor can be used to copy arrays:</span>
    <span class="hljs-type">int</span> myints[] = {<span class="hljs-number">16</span>,<span class="hljs-number">2</span>,<span class="hljs-number">77</span>,<span class="hljs-number">29</span>};
    <span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fifth</span><span class="hljs-params">(myints, myints + <span class="hljs-keyword">sizeof</span>(myints) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) )</span></span>;

    cout &lt;&lt; <span class="hljs-string">&quot;The contents of fifth are:&quot;</span>;
    <span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-type">int</span>&gt;::iterator it = fifth.<span class="hljs-built_in">begin</span>(); it!=fifth.<span class="hljs-built_in">end</span>(); ++it)
        cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *it;
    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;

    deque&lt;<span class="hljs-type">int</span>&gt; mydeque;
    mydeque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">100</span>);
    mydeque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">200</span>);
    mydeque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">300</span>);
    mydeque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">255</span>);

    cout &lt;&lt; mydeque.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; | .. | &quot;</span> &lt;&lt; mydeque.<span class="hljs-built_in">back</span>() &lt;&lt; endl;

    <span class="hljs-comment">// This do not return the content, only eliminate then!</span>
    mydeque.<span class="hljs-built_in">pop_front</span>();
    mydeque.<span class="hljs-built_in">pop_back</span>();
    cout &lt;&lt; mydeque.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; | .. | &quot;</span> &lt;&lt; mydeque.<span class="hljs-built_in">back</span>() &lt;&lt; endl;
}

</code></pre>
<h1 id="minimum-queue">Minimum Queue</h1>
<p>Essa estrutura serve para adicionar e remover elementos de um conjunto em tempo constante, e consultar o menor elemento do conjunto em tempo constante.</p>
<p>Para essa estrutura funcionar de maneira correta, cada elementos inserido na stack deve ser removido somente após todos os elementos que já foram inseridos antes tenham sido removidos. Exemplo: insere(A),insere(B),insere(C),remove(A),remove(B),remove(C).</p>
<p>Dessa forma os itens só podem serem removidos na ordem que foram inseridos.</p>
<p>Tempos de inserção, remoção e consulta são em média O(1).</p>
<p>Mais informações pode ser visto <a href="https://cp-algorithms.com/data_structures/stack_queue_modification.html">aqui</a>.</p>
<p>Obs: É possivel adaptar o código para ter a <em>Maximum Queue</em>, no qual o valor importante é o máximo.</p>
<h2 id="c---minimum-queue">C++ - <a href="https://cp-algorithms.com/data_structures/stack_queue_modification.html">Minimum Queue</a></h2>
<pre><code class="language-C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinimiumQueue</span>{
<span class="hljs-keyword">private</span>:
    deque&lt;<span class="hljs-type">int</span>&gt; queue;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> queue.<span class="hljs-built_in">front</span>();
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> new_element)</span></span>{
        <span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>() &amp;&amp; queue.<span class="hljs-built_in">back</span>()&gt;new_element){
            queue.<span class="hljs-built_in">pop_back</span>();
        }
        queue.<span class="hljs-built_in">push_back</span>(new_element);
    }

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rem</span><span class="hljs-params">(<span class="hljs-type">int</span> element)</span></span>{
        <span class="hljs-keyword">if</span> (!queue.<span class="hljs-built_in">empty</span>() &amp;&amp; queue.<span class="hljs-built_in">front</span>()==element)
            queue.<span class="hljs-built_in">pop_front</span>();
    }
};
</code></pre>
<h2 id="outra-implementação-para-minimum-queue">Outra Implementação para Minimum Queue</h2>
<pre><code class="language-cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MinQueue</span>
{
    deque&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; minQueue;
    <span class="hljs-type">int</span> contPush = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>
    </span>{
        <span class="hljs-comment">// se (minQueue.back().first &lt; num), vira maxQueue</span>
        <span class="hljs-keyword">while</span>(!minQueue.<span class="hljs-built_in">empty</span>() &amp;&amp; minQueue.<span class="hljs-built_in">back</span>().first &gt; num)
        {
            minQueue.<span class="hljs-built_in">pop_back</span>();
        }

        minQueue.<span class="hljs-built_in">push_back</span>({num, contPush});
        contPush++;
    }

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>)</span>
    </span>{
        <span class="hljs-keyword">while</span>(start &gt; minQueue.<span class="hljs-built_in">front</span>().second)
        {
            minQueue.<span class="hljs-built_in">pop_front</span>();
        }

        <span class="hljs-keyword">return</span> minQueue.<span class="hljs-built_in">front</span>().first;
    }
};
</code></pre>
<p>Para utilizar, considere que <code>m</code> seja o tamanho dos subvetores e <code>n</code> o tamanho total do vetor.</p>
<pre><code class="language-cpp">MinQueue minq;

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)
{
    minq.<span class="hljs-built_in">add</span>(v[i]);
}

<span class="hljs-comment">// start = 0</span>
cout &lt;&lt; minq.<span class="hljs-built_in">getMin</span>() &lt;&lt; endl;

<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= v.<span class="hljs-built_in">size</span>() - m; i++)
{
    minq.<span class="hljs-built_in">add</span>(v[i + m - <span class="hljs-number">1</span>]);
       
    <span class="hljs-comment">// start = i  </span>
    cout &lt;&lt; minq.<span class="hljs-built_in">getMin</span>(i) &lt;&lt; endl;
}
</code></pre>
<h2 id="exercícios">Exercícios</h2>
<ul>
<li><a href="https://www.hackerrank.com/challenges/queries-with-fixed-length/problem">Queries with Fixed Length</a></li>
<li><a href="https://www.codechef.com/MAY20A/problems/BINLAND">Binary Land</a></li>
</ul>
<h1 id="heap-arvore-binaria-em-array">Heap (Arvore binaria em array)</h1>
<p>O heap simula uma arvore binária em um array e sempre mantem o elemento de maior prioridade mais próximo do topo. Consegue ser muito eficiente na inserção de itens e remoção do item de maior prioridade. Com essa estrutura não é possivel acessar elementos sem ser o elemento do topo.</p>
<p>Aplicações:</p>
<ul>
<li>Dijkstra</li>
<li>Priority Queue (fila)</li>
</ul>
<h2 id="c---stdpriority_queue">C++ - <a href="https://cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a></h2>
<p>Priority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.</p>
<p>This context is similar to a heap, where elements can be inserted at any moment, and only the max heap element can be retrieved (the one at the top in the priority queue).</p>
<h3 id="default-behavior">Default behavior</h3>
<p>Note the prioriry_queue by default leave the <strong>biggest</strong> value at the top, unless you use custom compare function.</p>
<h3 id="custom-compare-function">Custom compare function</h3>
<p>A binary predicate that takes two elements (of type T) as arguments and returns a bool.
The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.</p>
<p>The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering). This can be a function pointer or a function object, and defaults to less<T>, which returns the same as applying the less-than operator (a&lt;b).</p>
<p>The use of compare function pointer is examplified as follow.</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>          <span class="hljs-comment">// std::priority_queue</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>         <span class="hljs-comment">// std::vector</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span>     <span class="hljs-comment">// std::greater</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>
{
  <span class="hljs-type">bool</span> reverse;
<span class="hljs-keyword">public</span>:
  <span class="hljs-built_in">mycomparison</span>(<span class="hljs-type">const</span> <span class="hljs-type">bool</span>&amp; revparam=<span class="hljs-literal">false</span>)
    {reverse=revparam;}
  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;rhs)</span> <span class="hljs-type">const</span>
  </span>{
    <span class="hljs-keyword">if</span> (reverse) <span class="hljs-keyword">return</span> (lhs&gt;rhs);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (lhs&lt;rhs);
  }
};

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>
</span>{
  <span class="hljs-type">int</span> myints[]= {<span class="hljs-number">10</span>,<span class="hljs-number">60</span>,<span class="hljs-number">50</span>,<span class="hljs-number">20</span>};

  std::priority_queue&lt;<span class="hljs-type">int</span>&gt; first;
  <span class="hljs-function">std::priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">second</span> <span class="hljs-params">(myints,myints+<span class="hljs-number">4</span>)</span></span>;
  std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt; &gt;
                            <span class="hljs-built_in">third</span> (myints,myints+<span class="hljs-number">4</span>);
  <span class="hljs-comment">// using mycomparison:</span>
  <span class="hljs-keyword">typedef</span> std::priority_queue&lt;<span class="hljs-type">int</span>,std::vector&lt;<span class="hljs-type">int</span>&gt;,mycomparison&gt; mypq_type;

  mypq_type fourth;                       <span class="hljs-comment">// less-than comparison</span>
  <span class="hljs-function">mypq_type <span class="hljs-title">fifth</span> <span class="hljs-params">(mycomparison(<span class="hljs-literal">true</span>))</span></span>;   <span class="hljs-comment">// greater-than comparison</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>As principais funções utilizadas nas listas são as citadas abaixo:</p>
<h3 id="getters-3">Getters:</h3>
<ul>
<li>top(): retorna o elemento no topo da queue, é o próximo que vai ser removido no pop;</li>
</ul>
<h3 id="capacidade-2">Capacidade:</h3>
<ul>
<li>size(): retorna o tamanho da lista;</li>
<li>empty(): retorna true se a lista estiver vazio;</li>
</ul>
<h3 id="modificadores-3">Modificadores:</h3>
<ul>
<li>push(): adiciona um elemento a fila de prioridade;</li>
<li>pop(): remove o elemento no topo da fila de prioridade;</li>
</ul>
<h2 id="python---heap">Python - <a href="https://docs.python.org/3/library/heapq.html">Heap</a></h2>
<p>O python tem filas utilizando a biblioteca <em>heapq</em> que já vem por padrão com o python nas versões mais recentes. (&gt;=3.7)</p>
<p>As funções utilizados no heap são citadas abaixo:</p>
<h3 id="modificadores-4">Modificadores:</h3>
<ul>
<li>heappush(): adiciona um elemento ao array heap;</li>
<li>heappop(): remove o menor elemento do array heap;</li>
<li>heappushpop(): adiciona um elemento ao array heap e remove o menor elemento, é mais eficiente que executar as duas funções em separado;</li>
<li>heapify(): transforma um array em um array heap;</li>
</ul>
<p>Exemplo:</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> heapq

arr = [<span class="hljs-number">5</span>,<span class="hljs-number">17</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]

arr = heapq.heapify(arr)  <span class="hljs-comment"># transform unsorted array in heapified array</span>

heapq.heappush(arr,<span class="hljs-number">6</span>) <span class="hljs-comment"># add 6 to heap array</span>
heapq.heappush(arr,<span class="hljs-number">17</span>) <span class="hljs-comment"># add 17 to heap array</span>
v1 = heapq.heappop(arr) <span class="hljs-comment"># return the smallest element from heap array</span>

v2 = heapq.heappushpop(arr,<span class="hljs-number">4</span>) <span class="hljs-comment"># return the smallest elemento and push 4 to heap array</span>

</code></pre>
<h1 id="hash-map">Hash Map</h1>
<p>Em um HashMap, o valor da chave geralmente é usado para identificar exclusivamente o elemento, enquanto o valor mapeado é um objeto com o conteúdo associado a essa chave. Os tipos de chave e valor mapeado podem ser diferentes.</p>
<p>Internamente, os elementos no HashMap não são classificados em nenhuma ordem específica com relação a sua chave ou valores mapeados, mas organizados em baldes dependendo de seus valores de hash para permitir acesso rápido a elementos individuais diretamente por seus valores de chave (com uma constante complexidade de tempo média em média).</p>
<h2 id="c---stdunsorted_map">C++ - <a href="https://cplusplus.com/reference/unordered_map/unordered_map/">std::unsorted_map</a></h2>
<p>Vale destacar que a <code>std::unsortedmap</code> é implementada utilizando um hashmap, o que faz com que sua inserção, busca e remoção seja feito em tempo O(1), enquanto a <code>std::map</code> utiliza a implementação de uma <a href="./BinaryTree.html">árvore binária</a> Red-Black, que já se mantém balanceada, então suas operações tem custo O(log n).</p>
<p>Nesse tópico vou apresentar as principais características da estrutura <code>std::unsortedmap</code>
Para saber mais sobre <code>std::map</code>, <a href="./BinaryTree.html">clique aqui</a></p>
<h3 id="associativo">Associativo</h3>
<p>Os elementos em contêineres associativos são referenciados por sua chave e não por sua posição absoluta no contêiner.</p>
<h3 id="não-ordenado">Não ordenado</h3>
<p>Os contêineres não ordenados organizam seus elementos usando tabelas de hash que permitem acesso rápido aos elementos por sua chave.</p>
<h3 id="mapa">Mapa</h3>
<p>Cada elemento associa uma chave a um valor mapeado: As chaves servem para identificar os elementos cujo conteúdo principal é o valor mapeado.</p>
<h3 id="iteração-2">Iteração:</h3>
<ul>
<li>begin(): retorna um iterador a partir do inicio do vetor;</li>
<li>end(): retorna um iterador a partir do fim do vetor (não pega a ultima casa);</li>
</ul>
<h3 id="getters-4">Getters:</h3>
<ul>
<li>operator[]: retorna o elemento da <em>chave</em> indicada dentro do operator. Caso seja uma chave que não existe é inserido um novo item com o construtor padrão (para números geralmente é zero) e retornado uma referencia desse item;</li>
<li>find(): retorna um iterador a partir desse elemento, caso não encontre retorna o map.end();</li>
</ul>
<h3 id="capacidade-3">Capacidade:</h3>
<ul>
<li>size(): retorna o tamanho do vetor;</li>
<li>empty(): retorna true se o vetor estiver vazio;</li>
</ul>
<h3 id="modificadores-5">Modificadores:</h3>
<ul>
<li>insert(): existem algumas versões para o insert, sendo elas:</li>
<li>insert(std::pair&lt;K,V&gt;): insere um objeto par dentro do map;</li>
<li>insert(K,V): insere o valor V na posição K;</li>
<li>erase(): apaga um elemento na posição passada, note que para remover o elemento da posição 4 deve-se chamar a função begin() e somar a 4;</li>
<li>erase(iterator): remove o item dessa posição do iterador;</li>
<li>erase(start,end): remove os items desde a posição start até end;</li>
</ul>
<h2 id="python---dictionaries">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries</a></h2>
<p>Os <em>dictionaries</em> não possuem nenhuma função importante, e todos as manipulações deles são exemplificadas abaixo:</p>
<pre><code class="language-python">
d1 = {} <span class="hljs-comment"># forma de criar um dicionário vazio</span>
d2 = {
  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;S1&#x27;</span>, 
  <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;s2&#x27;</span>
} <span class="hljs-comment"># forma de criar um dicionário com elementos já</span>
d3 = {x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)} <span class="hljs-comment"># declarar um dicionario com elementos dinamicos</span>

bool1 = <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> d1 <span class="hljs-comment"># forma de verificar se a chave existe no dicionario</span>
bool2 = <span class="hljs-number">2</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d1 <span class="hljs-comment"># forma de verificar se a chave não existe no dicionario</span>

d1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;ola mundo&#x27;</span> <span class="hljs-comment"># forma de adicionar item no dicionario</span>
d1[<span class="hljs-number">1</span>] += <span class="hljs-string">&#x27;!&#x27;</span> <span class="hljs-comment"># é possivel manipular os itens do dicionaro também</span>

<span class="hljs-keyword">del</span> d1[<span class="hljs-number">1</span>] <span class="hljs-comment"># deleta o item com a chave 1 do dicionário</span>


<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d1:  <span class="hljs-comment"># essa é a forma de iterar sobre o dicionário, porém o valor que é iterado é sobre as chaves, e não sobre os valores</span>
    <span class="hljs-built_in">print</span>(key,d1[key])

<span class="hljs-keyword">for</span> key,val <span class="hljs-keyword">in</span> d1.items():  <span class="hljs-comment"># essa é a forma de iterar sobre o dicionário incluindo os valores</span>
    <span class="hljs-built_in">print</span>(key,val)

l = <span class="hljs-built_in">list</span>(d1)  <span class="hljs-comment"># cria uma lista com todas as chaves do dicionário</span>
l = <span class="hljs-built_in">list</span>(d1.items())  <span class="hljs-comment"># cria uma lista com tuplas contendo a relação entre chave e valor</span>

</code></pre>
<h1 id="conjutos-set">Conjutos (Set)</h1>
<p>Conjutos (set) são container que armazenam valores em uma estrutura de dados, com inserção, remoção e acesso constante. Geralmente usam <a href="./HashMap.html">HashMap</a>.</p>
<h2 id="c---stdunordered_set">C++ - <a href="https://cplusplus.com/reference/unordered_set/unordered_set/">std::unordered_set</a></h2>
<p>Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value.</p>
<h3 id="associação">Associação</h3>
<p>Elements in associative containers are referenced by their key and not by their absolute position in the container.</p>
<h3 id="set">Set</h3>
<p>The value of an element is also the key used to identify it.</p>
<p>As principais funções utilizadas em sets são as citadas abaixo:</p>
<h3 id="iteração-3">Iteração:</h3>
<ul>
<li>begin(): retorna um iterador a partir do inicio da lista;</li>
<li>end(): retorna um iterador a partir do fim da lista (não pega a ultima casa);</li>
<li>rbegin(): retorna um iterador <em>reverso</em> a partir do fim da lista;</li>
<li>rend(): retorna um iterador <em>reverso</em> a partir do inicido da lista (não pega a primeira casa);</li>
</ul>
<h3 id="capacidade-4">Capacidade:</h3>
<ul>
<li>size(): retorna o tamanho da lista;</li>
<li>empty(): retorna true se a lista estiver vazio;</li>
</ul>
<h3 id="modificadores-6">Modificadores:</h3>
<ul>
<li>insert(): existem algumas versões para o insert, sendo elas:</li>
<li>insert(val): insere o item val;</li>
<li>insert(iterator pos, val): a partir da posição passada insere o item val, ainda vai manter a ordem, porém pode adicionar eficiencia se a posição do iterator passada estiver próxima do local onde o item deve ser inserido;</li>
<li>erase(): apaga um elemento na posição passada, a posição passada sempre é um iterator na posição que deseja remover;</li>
<li>clear(): limpa todos os dados do set;</li>
</ul>
<h3 id="getters-5">Getters:</h3>
<ul>
<li>find(): retorna um iterator se existir aquele dado no set, se não existir ele retorna um iterator end()</li>
</ul>
<h2 id="python---set">Python - <a href="https://docs.python.org/3/tutorial/datastructures.html#sets">set</a></h2>
<p>As principais funções de set em python são exemplificadas abaixo:</p>
<pre><code class="language-python">
v = {<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;tomate&#x27;</span>, <span class="hljs-string">&#x27;arroz&#x27;</span>} <span class="hljs-comment"># create a set</span>

<span class="hljs-string">&#x27;banana&#x27;</span> <span class="hljs-keyword">in</span> v <span class="hljs-comment"># True</span>

<span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> v: <span class="hljs-comment"># for each item in set</span>
    <span class="hljs-keyword">pass</span>

v.add(<span class="hljs-string">&#x27;laranja&#x27;</span>) <span class="hljs-comment"># add item to set</span>
v.remove(<span class="hljs-string">&#x27;banana&#x27;</span>) <span class="hljs-comment"># remove item from set</span>

d = {<span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;tomate&#x27;</span>, <span class="hljs-string">&#x27;feijão&#x27;</span>}

d | v <span class="hljs-comment"># in set d or v</span>
d - v <span class="hljs-comment"># in d but not in v (order matters)</span>
d &amp; v <span class="hljs-comment"># in both sets (d and v)</span>
d ^ v <span class="hljs-comment"># in set d or in set v but not in both</span>

</code></pre>
<h1 id="disjoin">Disjoin</h1>
<p>É uma estrutura capaz de manter rastreamento de quais 'chaves' pertencem a quais conjuntos em tempo O(1) e fazer a união de conjuntos em tempo O(n) ao menos. É muito útil quando trabalhando com grafos usando o algoritmo Kruskal's e precisa rastrear quais nós percencem a quais conjuntos para evitar criar um ciclo.</p>
<p>Possue no mínimo duas funções:</p>
<ul>
<li>Find(x): qual o conjunto no qual <em>x</em> faz parte?</li>
<li>Union(x,y): unir o conjunto de <em>x</em> e de <em>y</em> e torna-los um só.</li>
</ul>
<h2 id="c---disjoin">C++ - <a href="https://www.geeksforgeeks.org/disjoint-set-union-randomized-algorithm/">Disjoin</a></h2>
<p>O algoritmo abaixo é extremamente eficiente, sendo a busca e a união em O(alpha(n))</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSetUnion</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Constructor that initializes the parent and size arrays</span>
    <span class="hljs-built_in">DisjointSetUnion</span>(<span class="hljs-type">int</span> n) {
        parent = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);
        <span class="hljs-comment">// this is the size of height of current three node</span>
        size = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            parent[i] = i;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>{
       <span class="hljs-keyword">if</span> (parent[x] != x) {
           parent[x] = <span class="hljs-built_in">Find</span>(parent[x]);
       }
       <span class="hljs-keyword">return</span> parent[x];
    }
     
     
    <span class="hljs-comment">// Merge the sets containing elements x and y</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-type">int</span> root_x = <span class="hljs-built_in">find</span>(x);
        <span class="hljs-type">int</span> root_y = <span class="hljs-built_in">find</span>(y);
        <span class="hljs-keyword">if</span> (root_x == root_y) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">// Chose the bigger three to be the root</span>
        cout &lt;&lt; size[root_y] &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; size[root_x] &lt;&lt; endl;
        <span class="hljs-keyword">if</span>(size[root_y] &gt; size[root_x])
            <span class="hljs-built_in">swap</span>(root_x,root_y);
        <span class="hljs-comment">// increase the three size</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size[root_x] == size[root_y])
            size[root_x]++;

        parent[root_y] = root_x;

    }
     
<span class="hljs-keyword">private</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; parent;
    vector&lt;<span class="hljs-type">int</span>&gt; size;
};
</code></pre>
<h2 id="python---disjoin">Python - <a href="https://www.geeksforgeeks.org/disjoint-set-union-randomized-algorithm/">Disjoin</a></h2>
<p>O algoritmo abaixo é extremamente eficiente, sendo a busca e a união em O(alpha(n))</p>
<pre><code class="language-python"> 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSetUnion</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):
        self.parent = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]
        self.size = [<span class="hljs-number">1</span>] * n
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, x</span>):
       <span class="hljs-keyword">if</span> self.parent[x] != x:
           self.parent[x] = self.find(self.parent[x])
       <span class="hljs-keyword">return</span> self.parent[x] 

    <span class="hljs-comment"># This function depends of the find method</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">self, x, y</span>):
        root_x = self.find(x)
        root_y = self.find(y)
        <span class="hljs-keyword">if</span> root_x == root_y:
            <span class="hljs-keyword">return</span>

        <span class="hljs-keyword">if</span> self.size[root_y] &gt; self.size[root_x]:
            root_x, root_y = root_y, root_x
        <span class="hljs-keyword">elif</span> self.size[root_y] == self.size[root_x]:
            self.size[root_x] += <span class="hljs-number">1</span>
 
        self.parent[root_y] = root_x
</code></pre>
<h1 id="disjoint-sparse-table">Disjoint Sparse Table</h1>
<p>Eu realmente não entendi direito. É uma estrutura de segtree porém utiliza operações de bitwise para achar o nó do range correto em <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> fazer queries executarem em <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>Build: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>
Query: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h3 id="c">C++</h3>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000000</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXPOWN 1048576 <span class="hljs-comment">// 2^(ceil(log_2(MAXN)))</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEV 21       <span class="hljs-comment">// ceil(log_2(MAXN)) + 1</span></span>

<span class="hljs-type">int</span> arr[MAXPOWN] = {<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>};
<span class="hljs-type">int</span> table[MAXLEV][MAXPOWN];
<span class="hljs-type">int</span> maxlev, size;

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>
</span>{
    size = n;
    maxlev = __builtin_clz(n) ^ <span class="hljs-number">31</span>; <span class="hljs-comment">// floor(log_2(n))</span>
    <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; maxlev) != n)
        size = <span class="hljs-number">1</span> &lt;&lt; ++maxlev;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(a, b);
    <span class="hljs-comment">// return max(a,b);</span>
    <span class="hljs-comment">// return a^b;</span>
    <span class="hljs-comment">// return a+b;</span>
    <span class="hljs-comment">// return ((long long)a*b)%SOME_PRIME</span>
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> level = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> r = size)</span>
</span>{
    <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;

    table[level][m] = arr[m];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= l; i--)
        table[level][i] = <span class="hljs-built_in">compute</span>(table[level][i + <span class="hljs-number">1</span>], arr[i]);

    <span class="hljs-keyword">if</span> (m + <span class="hljs-number">1</span> &lt; r)
    {
        table[level][m + <span class="hljs-number">1</span>] = arr[m + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m + <span class="hljs-number">2</span>; i &lt; r; i++)
            table[level][i] = <span class="hljs-built_in">compute</span>(table[level][i - <span class="hljs-number">1</span>], arr[i]);
    }

    <span class="hljs-keyword">if</span> (l + <span class="hljs-number">1</span> != r) <span class="hljs-comment">// r - l &gt; 1</span>
    {
        <span class="hljs-built_in">build</span>(level + <span class="hljs-number">1</span>, l, m);
        <span class="hljs-built_in">build</span>(level + <span class="hljs-number">1</span>, m, r);
    }
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
</span>{
    <span class="hljs-keyword">if</span> (x == y)
        <span class="hljs-keyword">return</span> arr[x];
    <span class="hljs-type">int</span> k2 = __builtin_clz(x ^ y) ^ <span class="hljs-number">31</span>;
    <span class="hljs-type">int</span> lev = maxlev - <span class="hljs-number">1</span> - k2;
    <span class="hljs-type">int</span> ans = table[lev][x];
    <span class="hljs-keyword">if</span> (y &amp; ((<span class="hljs-number">1</span> &lt;&lt; k2) - <span class="hljs-number">1</span>)) <span class="hljs-comment">// y % (1&lt;&lt;k2)</span>
        ans = <span class="hljs-built_in">compute</span>(ans, table[lev][y]);
    <span class="hljs-keyword">return</span> ans;
}

</code></pre>
<p>Note:</p>
<ul>
<li>I assume that size of int is 32 bits</li>
<li>__builtin_clz() is an inbuilt function in gcc compiler(not in C++ standard) which returns the count of leading zeroes(hence the name)</li>
<li>31 - num = 31 ^ num. This this true for any number of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>